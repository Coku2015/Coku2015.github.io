<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据集成API真的就只是API？ | Backup next cloud</title><meta name=keywords content="Automation,Powershell"><meta name=description content="Veeam发布v10之后，推出了一个全新的功能，但是这个功能深深的埋藏在了Powershell API之下，并且被冠了一个令人高不可攀的名称：数据集成API。我相信很多朋友看完这个名字，就可能不太想了解这个功能。对于系统管理员来说，有点略复杂了，还要开发什么东西才能把这个用起来？算了还是不用了。
功能 其实这个功能并不是那么的复杂，我们先来了解下怎么回事。
这个功能其实是通过iSCSI的磁盘服务，将备份存档通过iSCSI发布给相关服务器使用。它是数据利用的新形态，也就是说任何的Veeam的镜像级备份存档，都可以通过这种形式挂载给服务器去访问里面的数据。它和即时虚拟机恢复有那么一点点像，但是完全不一样的是，它完全不依赖于虚拟化环境，不依赖VMware和Hyper-V，而是将数据直接通过iSCSI服务发布给Windows或者Linux系统访问。在VBR中，绝大多数镜像级的备份存档都支持这种形式的发布：
 VMware镜像级备份 VMware镜像级复制 Hyper-V镜像级备份 Hyper-V镜像级复制 Veeam Agent for Windows的镜像级备份 Veeam Agent for Linux的镜像级备份  原理 iSCSI挂载的工作原理非常简单，在API发起后，VBR的挂载服务器相当于变成一台iSCSI的存储机头，它能为所有可以访问iSCSI存储的系统提供iSCSI的服务，而这里面提供出去的数据则是VBR的存档，管理员可以按需从备份或复制存档中选择需要的数据。在这个数据集成服务建立起来后，数据使用者可以通过iSCSI的存储协议，直接挂载发布出来的卷，读取其中的数据，使用其中的数据。如图所示，在数据集成服务将备份存档发布后，备份系统变成了一套iSCSI的存储系统，里面存放的数据是之前的历史备份数据。
使用方法 因为它以API形式开放给用户使用，因此在VBR控制台上并没有直接的按钮来使用，但是这完全挡不住我们使用这么优秀的功能。可以直接使用本文最后面的这个Powershell的脚本来实现这个功能，需要做的很简单，只要copy脚本内容到记事本，存成.ps1文件，然后在VBR服务器的Powershell控制台中执行这个交互式脚本即可，按照脚本执行过程中的提示输入必要的信息就能成功将存档通过iSCSI发布出来了。
执行脚本后，会看到Powershell控制台上输入内容后会看到以下效果：
而此时，在VBR上会看到发布出来的磁盘信息，它以Instant Recovery显示在VBR控制台中。
接下来，我们可以来到iSCSI客户端上，比如刚刚在脚本执行时输入IP地址的机器10.10.1.175上，打开Windows的iSCSI Initiator，填入iSCSI的target为10.10.1.201，端口默认3260，来挂载这个iSCSI卷了。
在使用结束后，不要忘了在VBR上点击Stop Publishing来回收这个iSCSI卷。
以上就是简单实用的新功能，iSCSI发布。赶紧下载VBR装上试一下吧。
附上脚本：
# 本脚本是Veeam DataIntegration API的使用样例 # 用于通过iSCSI方式将备份数据挂载给指定的系统进行使用 # 使用脚本需要至少有7个还原点以上，否则请修改脚本使用 # 脚本暂时仅限VMware、Hyper-V的主备份存档，如需Agent、Backup Copy、Replication、Storage Snapshot，请根据需求修改脚本。 # # 脚本作者：Wei Lei # Email:lei.wei@veeam.com # 脚本版本：v1.1 ################# Update log ###################### # 更新了VBR用户名密码错误后立刻停止脚本； # 更新了还原点选择错误后，自动终止脚本； ################################################### # Script Start # VBR Server (Server Name, FQDN or IP) $vbrServer = Read-Host &#34;请输入VBR地址，可以是域名或者IP&#34; # VBR Credentials Write-Host &#34;请在弹出对话框中输入VBR的用户名密码。&#34; $Credential=Get-Credential -Message 请输入VBR的用户名密码 $vbrusername = $Credential."><meta name=author content="Lei Wei"><link rel=canonical href=https://newblog.backupnext.cloud/post/2020-07-13-data-integration-api/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://newblog.backupnext.cloud/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://newblog.backupnext.cloud/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://newblog.backupnext.cloud/favicon-32x32.png><link rel=apple-touch-icon href=https://newblog.backupnext.cloud/apple-touch-icon.png><link rel=mask-icon href=https://newblog.backupnext.cloud/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="数据集成API真的就只是API？"><meta property="og:description" content="Veeam发布v10之后，推出了一个全新的功能，但是这个功能深深的埋藏在了Powershell API之下，并且被冠了一个令人高不可攀的名称：数据集成API。我相信很多朋友看完这个名字，就可能不太想了解这个功能。对于系统管理员来说，有点略复杂了，还要开发什么东西才能把这个用起来？算了还是不用了。
功能 其实这个功能并不是那么的复杂，我们先来了解下怎么回事。
这个功能其实是通过iSCSI的磁盘服务，将备份存档通过iSCSI发布给相关服务器使用。它是数据利用的新形态，也就是说任何的Veeam的镜像级备份存档，都可以通过这种形式挂载给服务器去访问里面的数据。它和即时虚拟机恢复有那么一点点像，但是完全不一样的是，它完全不依赖于虚拟化环境，不依赖VMware和Hyper-V，而是将数据直接通过iSCSI服务发布给Windows或者Linux系统访问。在VBR中，绝大多数镜像级的备份存档都支持这种形式的发布：
 VMware镜像级备份 VMware镜像级复制 Hyper-V镜像级备份 Hyper-V镜像级复制 Veeam Agent for Windows的镜像级备份 Veeam Agent for Linux的镜像级备份  原理 iSCSI挂载的工作原理非常简单，在API发起后，VBR的挂载服务器相当于变成一台iSCSI的存储机头，它能为所有可以访问iSCSI存储的系统提供iSCSI的服务，而这里面提供出去的数据则是VBR的存档，管理员可以按需从备份或复制存档中选择需要的数据。在这个数据集成服务建立起来后，数据使用者可以通过iSCSI的存储协议，直接挂载发布出来的卷，读取其中的数据，使用其中的数据。如图所示，在数据集成服务将备份存档发布后，备份系统变成了一套iSCSI的存储系统，里面存放的数据是之前的历史备份数据。
使用方法 因为它以API形式开放给用户使用，因此在VBR控制台上并没有直接的按钮来使用，但是这完全挡不住我们使用这么优秀的功能。可以直接使用本文最后面的这个Powershell的脚本来实现这个功能，需要做的很简单，只要copy脚本内容到记事本，存成.ps1文件，然后在VBR服务器的Powershell控制台中执行这个交互式脚本即可，按照脚本执行过程中的提示输入必要的信息就能成功将存档通过iSCSI发布出来了。
执行脚本后，会看到Powershell控制台上输入内容后会看到以下效果：
而此时，在VBR上会看到发布出来的磁盘信息，它以Instant Recovery显示在VBR控制台中。
接下来，我们可以来到iSCSI客户端上，比如刚刚在脚本执行时输入IP地址的机器10.10.1.175上，打开Windows的iSCSI Initiator，填入iSCSI的target为10.10.1.201，端口默认3260，来挂载这个iSCSI卷了。
在使用结束后，不要忘了在VBR上点击Stop Publishing来回收这个iSCSI卷。
以上就是简单实用的新功能，iSCSI发布。赶紧下载VBR装上试一下吧。
附上脚本：
# 本脚本是Veeam DataIntegration API的使用样例 # 用于通过iSCSI方式将备份数据挂载给指定的系统进行使用 # 使用脚本需要至少有7个还原点以上，否则请修改脚本使用 # 脚本暂时仅限VMware、Hyper-V的主备份存档，如需Agent、Backup Copy、Replication、Storage Snapshot，请根据需求修改脚本。 # # 脚本作者：Wei Lei # Email:lei.wei@veeam.com # 脚本版本：v1.1 ################# Update log ###################### # 更新了VBR用户名密码错误后立刻停止脚本； # 更新了还原点选择错误后，自动终止脚本； ################################################### # Script Start # VBR Server (Server Name, FQDN or IP) $vbrServer = Read-Host &#34;请输入VBR地址，可以是域名或者IP&#34; # VBR Credentials Write-Host &#34;请在弹出对话框中输入VBR的用户名密码。&#34; $Credential=Get-Credential -Message 请输入VBR的用户名密码 $vbrusername = $Credential."><meta property="og:type" content="article"><meta property="og:url" content="https://newblog.backupnext.cloud/post/2020-07-13-data-integration-api/"><meta property="article:section" content="post"><meta property="og:site_name" content="Backup next Cloud"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据集成API真的就只是API？"><meta name=twitter:description content="Veeam发布v10之后，推出了一个全新的功能，但是这个功能深深的埋藏在了Powershell API之下，并且被冠了一个令人高不可攀的名称：数据集成API。我相信很多朋友看完这个名字，就可能不太想了解这个功能。对于系统管理员来说，有点略复杂了，还要开发什么东西才能把这个用起来？算了还是不用了。
功能 其实这个功能并不是那么的复杂，我们先来了解下怎么回事。
这个功能其实是通过iSCSI的磁盘服务，将备份存档通过iSCSI发布给相关服务器使用。它是数据利用的新形态，也就是说任何的Veeam的镜像级备份存档，都可以通过这种形式挂载给服务器去访问里面的数据。它和即时虚拟机恢复有那么一点点像，但是完全不一样的是，它完全不依赖于虚拟化环境，不依赖VMware和Hyper-V，而是将数据直接通过iSCSI服务发布给Windows或者Linux系统访问。在VBR中，绝大多数镜像级的备份存档都支持这种形式的发布：
 VMware镜像级备份 VMware镜像级复制 Hyper-V镜像级备份 Hyper-V镜像级复制 Veeam Agent for Windows的镜像级备份 Veeam Agent for Linux的镜像级备份  原理 iSCSI挂载的工作原理非常简单，在API发起后，VBR的挂载服务器相当于变成一台iSCSI的存储机头，它能为所有可以访问iSCSI存储的系统提供iSCSI的服务，而这里面提供出去的数据则是VBR的存档，管理员可以按需从备份或复制存档中选择需要的数据。在这个数据集成服务建立起来后，数据使用者可以通过iSCSI的存储协议，直接挂载发布出来的卷，读取其中的数据，使用其中的数据。如图所示，在数据集成服务将备份存档发布后，备份系统变成了一套iSCSI的存储系统，里面存放的数据是之前的历史备份数据。
使用方法 因为它以API形式开放给用户使用，因此在VBR控制台上并没有直接的按钮来使用，但是这完全挡不住我们使用这么优秀的功能。可以直接使用本文最后面的这个Powershell的脚本来实现这个功能，需要做的很简单，只要copy脚本内容到记事本，存成.ps1文件，然后在VBR服务器的Powershell控制台中执行这个交互式脚本即可，按照脚本执行过程中的提示输入必要的信息就能成功将存档通过iSCSI发布出来了。
执行脚本后，会看到Powershell控制台上输入内容后会看到以下效果：
而此时，在VBR上会看到发布出来的磁盘信息，它以Instant Recovery显示在VBR控制台中。
接下来，我们可以来到iSCSI客户端上，比如刚刚在脚本执行时输入IP地址的机器10.10.1.175上，打开Windows的iSCSI Initiator，填入iSCSI的target为10.10.1.201，端口默认3260，来挂载这个iSCSI卷了。
在使用结束后，不要忘了在VBR上点击Stop Publishing来回收这个iSCSI卷。
以上就是简单实用的新功能，iSCSI发布。赶紧下载VBR装上试一下吧。
附上脚本：
# 本脚本是Veeam DataIntegration API的使用样例 # 用于通过iSCSI方式将备份数据挂载给指定的系统进行使用 # 使用脚本需要至少有7个还原点以上，否则请修改脚本使用 # 脚本暂时仅限VMware、Hyper-V的主备份存档，如需Agent、Backup Copy、Replication、Storage Snapshot，请根据需求修改脚本。 # # 脚本作者：Wei Lei # Email:lei.wei@veeam.com # 脚本版本：v1.1 ################# Update log ###################### # 更新了VBR用户名密码错误后立刻停止脚本； # 更新了还原点选择错误后，自动终止脚本； ################################################### # Script Start # VBR Server (Server Name, FQDN or IP) $vbrServer = Read-Host &#34;请输入VBR地址，可以是域名或者IP&#34; # VBR Credentials Write-Host &#34;请在弹出对话框中输入VBR的用户名密码。&#34; $Credential=Get-Credential -Message 请输入VBR的用户名密码 $vbrusername = $Credential."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://newblog.backupnext.cloud/post/"},{"@type":"ListItem","position":2,"name":"数据集成API真的就只是API？","item":"https://newblog.backupnext.cloud/post/2020-07-13-data-integration-api/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据集成API真的就只是API？","name":"数据集成API真的就只是API？","description":"Veeam发布v10之后，推出了一个全新的功能，但是这个功能深深的埋藏在了Powershell API之下，并且被冠了一个令人高不可攀的名称：数据集成API。我相信很多朋友看完这个名字，就可能不太想了解这个功能。对于系统管理员来说，有点略复杂了，还要开发什么东西才能把这个用起来？算了还是不用了。\n功能 其实这个功能并不是那么的复杂，我们先来了解下怎么回事。\n这个功能其实是通过iSCSI的磁盘服务，将备份存档通过iSCSI发布给相关服务器使用。它是数据利用的新形态，也就是说任何的Veeam的镜像级备份存档，都可以通过这种形式挂载给服务器去访问里面的数据。它和即时虚拟机恢复有那么一点点像，但是完全不一样的是，它完全不依赖于虚拟化环境，不依赖VMware和Hyper-V，而是将数据直接通过iSCSI服务发布给Windows或者Linux系统访问。在VBR中，绝大多数镜像级的备份存档都支持这种形式的发布：\n VMware镜像级备份 VMware镜像级复制 Hyper-V镜像级备份 Hyper-V镜像级复制 Veeam Agent for Windows的镜像级备份 Veeam Agent for Linux的镜像级备份  原理 iSCSI挂载的工作原理非常简单，在API发起后，VBR的挂载服务器相当于变成一台iSCSI的存储机头，它能为所有可以访问iSCSI存储的系统提供iSCSI的服务，而这里面提供出去的数据则是VBR的存档，管理员可以按需从备份或复制存档中选择需要的数据。在这个数据集成服务建立起来后，数据使用者可以通过iSCSI的存储协议，直接挂载发布出来的卷，读取其中的数据，使用其中的数据。如图所示，在数据集成服务将备份存档发布后，备份系统变成了一套iSCSI的存储系统，里面存放的数据是之前的历史备份数据。\n使用方法 因为它以API形式开放给用户使用，因此在VBR控制台上并没有直接的按钮来使用，但是这完全挡不住我们使用这么优秀的功能。可以直接使用本文最后面的这个Powershell的脚本来实现这个功能，需要做的很简单，只要copy脚本内容到记事本，存成.ps1文件，然后在VBR服务器的Powershell控制台中执行这个交互式脚本即可，按照脚本执行过程中的提示输入必要的信息就能成功将存档通过iSCSI发布出来了。\n执行脚本后，会看到Powershell控制台上输入内容后会看到以下效果：\n而此时，在VBR上会看到发布出来的磁盘信息，它以Instant Recovery显示在VBR控制台中。\n接下来，我们可以来到iSCSI客户端上，比如刚刚在脚本执行时输入IP地址的机器10.10.1.175上，打开Windows的iSCSI Initiator，填入iSCSI的target为10.10.1.201，端口默认3260，来挂载这个iSCSI卷了。\n在使用结束后，不要忘了在VBR上点击Stop Publishing来回收这个iSCSI卷。\n以上就是简单实用的新功能，iSCSI发布。赶紧下载VBR装上试一下吧。\n附上脚本：\n# 本脚本是Veeam DataIntegration API的使用样例 # 用于通过iSCSI方式将备份数据挂载给指定的系统进行使用 # 使用脚本需要至少有7个还原点以上，否则请修改脚本使用 # 脚本暂时仅限VMware、Hyper-V的主备份存档，如需Agent、Backup Copy、Replication、Storage Snapshot，请根据需求修改脚本。 # # 脚本作者：Wei Lei # Email:lei.wei@veeam.com # 脚本版本：v1.1 ################# Update log ###################### # 更新了VBR用户名密码错误后立刻停止脚本； # 更新了还原点选择错误后，自动终止脚本； ################################################### # Script Start # VBR Server (Server Name, FQDN or IP) $vbrServer = Read-Host \u0026#34;请输入VBR地址，可以是域名或者IP\u0026#34; # VBR Credentials Write-Host \u0026#34;请在弹出对话框中输入VBR的用户名密码。\u0026#34; $Credential=Get-Credential -Message 请输入VBR的用户名密码 $vbrusername = $Credential.","keywords":["Automation","Powershell"],"articleBody":"Veeam发布v10之后，推出了一个全新的功能，但是这个功能深深的埋藏在了Powershell API之下，并且被冠了一个令人高不可攀的名称：数据集成API。我相信很多朋友看完这个名字，就可能不太想了解这个功能。对于系统管理员来说，有点略复杂了，还要开发什么东西才能把这个用起来？算了还是不用了。\n功能 其实这个功能并不是那么的复杂，我们先来了解下怎么回事。\n这个功能其实是通过iSCSI的磁盘服务，将备份存档通过iSCSI发布给相关服务器使用。它是数据利用的新形态，也就是说任何的Veeam的镜像级备份存档，都可以通过这种形式挂载给服务器去访问里面的数据。它和即时虚拟机恢复有那么一点点像，但是完全不一样的是，它完全不依赖于虚拟化环境，不依赖VMware和Hyper-V，而是将数据直接通过iSCSI服务发布给Windows或者Linux系统访问。在VBR中，绝大多数镜像级的备份存档都支持这种形式的发布：\n VMware镜像级备份 VMware镜像级复制 Hyper-V镜像级备份 Hyper-V镜像级复制 Veeam Agent for Windows的镜像级备份 Veeam Agent for Linux的镜像级备份  原理 iSCSI挂载的工作原理非常简单，在API发起后，VBR的挂载服务器相当于变成一台iSCSI的存储机头，它能为所有可以访问iSCSI存储的系统提供iSCSI的服务，而这里面提供出去的数据则是VBR的存档，管理员可以按需从备份或复制存档中选择需要的数据。在这个数据集成服务建立起来后，数据使用者可以通过iSCSI的存储协议，直接挂载发布出来的卷，读取其中的数据，使用其中的数据。如图所示，在数据集成服务将备份存档发布后，备份系统变成了一套iSCSI的存储系统，里面存放的数据是之前的历史备份数据。\n使用方法 因为它以API形式开放给用户使用，因此在VBR控制台上并没有直接的按钮来使用，但是这完全挡不住我们使用这么优秀的功能。可以直接使用本文最后面的这个Powershell的脚本来实现这个功能，需要做的很简单，只要copy脚本内容到记事本，存成.ps1文件，然后在VBR服务器的Powershell控制台中执行这个交互式脚本即可，按照脚本执行过程中的提示输入必要的信息就能成功将存档通过iSCSI发布出来了。\n执行脚本后，会看到Powershell控制台上输入内容后会看到以下效果：\n而此时，在VBR上会看到发布出来的磁盘信息，它以Instant Recovery显示在VBR控制台中。\n接下来，我们可以来到iSCSI客户端上，比如刚刚在脚本执行时输入IP地址的机器10.10.1.175上，打开Windows的iSCSI Initiator，填入iSCSI的target为10.10.1.201，端口默认3260，来挂载这个iSCSI卷了。\n在使用结束后，不要忘了在VBR上点击Stop Publishing来回收这个iSCSI卷。\n以上就是简单实用的新功能，iSCSI发布。赶紧下载VBR装上试一下吧。\n附上脚本：\n# 本脚本是Veeam DataIntegration API的使用样例 # 用于通过iSCSI方式将备份数据挂载给指定的系统进行使用 # 使用脚本需要至少有7个还原点以上，否则请修改脚本使用 # 脚本暂时仅限VMware、Hyper-V的主备份存档，如需Agent、Backup Copy、Replication、Storage Snapshot，请根据需求修改脚本。 # # 脚本作者：Wei Lei # Email:lei.wei@veeam.com # 脚本版本：v1.1 ################# Update log ###################### # 更新了VBR用户名密码错误后立刻停止脚本； # 更新了还原点选择错误后，自动终止脚本； ################################################### # Script Start # VBR Server (Server Name, FQDN or IP) $vbrServer = Read-Host \"请输入VBR地址，可以是域名或者IP\" # VBR Credentials Write-Host \"请在弹出对话框中输入VBR的用户名密码。\" $Credential=Get-Credential -Message 请输入VBR的用户名密码 $vbrusername = $Credential.Username $vbrpassword = $Credential.GetNetworkCredential().password #region Connect # Load Veeam Snapin If (!(Get-PSSnapin -Name VeeamPSSnapIn -ErrorAction SilentlyContinue)) { If (!(Add-PSSnapin -PassThru VeeamPSSnapIn)) { Write-Error \"Unable to load Veeam snapin\" -ForegroundColor Red Exit } } # Connect to VBR server $OpenConnection = (Get-VBRServerSession).Server If ($OpenConnection -ne $vbrServer) { Disconnect-VBRServer Try { Connect-VBRServer -user $vbrusername -password $vbrpassword -server $vbrServer -ErrorAction Stop } Catch { Write-Host \"无法连接到VBR服务器 - $vbrServer\" -ForegroundColor Red exit } } #endregion $VMName = Read-Host \"请输入需要用于挂载的虚拟机名称\" $IP =Read-Host \"要挂载到哪台服务器（IP地址）？\" $backup = Get-VBRBackup $backup = @($backup | ?{$_.JobType -eq \"Backup\"}) $points = Get-VBRRestorePoint -Backup $backup -Name $VMName | Sort-Object –Property CreationTime –Descending | Select-Object -First 7 if ($points -eq $null) { Write-Host \"找不到这台虚拟机的还原点。 - $VMName\" -ForegroundColor Red exit } While($InNumber -ne 7) { Write-Host \"##############已找到虚拟机 $VMName 的最近7个还原点##############\" -ForegroundColor Green $i = 0 foreach ($pt in $points) { $ptctime = $pt.CreationTime $i = $i + 1 Write-Host \"#\" $i . $ptctime \";\" } Write-Host \"#############################################################\" -ForegroundColor Green $InNumber = Read-Host \"请选择还原点（1-7）\" $ss =@() switch($InNumber) { 1 { $pt = $points | Select-Object -Index 0 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } 2 { $pt = $points | Select-Object -Index 1 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } 3 { $pt = $points | Select-Object -Index 2 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } 4 { $pt = $points | Select-Object -Index 3 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } 5 { $pt = $points | Select-Object -Index 4 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } 6 { $pt = $points | Select-Object -Index 5 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } 7 { $pt = $points | Select-Object -Index 6 $pttime = $pt.CreationTime Write-Host \"已选择还原点 $pttime 。\" -ForegroundColor Green $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync } Default { Write-Error \"请输入1-7之间的数字!\" Invoke-Command {exit} } } Write-Host \"正在挂载还原点...\" $state = $ss.StateString $ssid = $ss.id While ($state -ne \"Virtual disks published...\") { Start-Sleep -s 5 $ss = Get-VBRPublishedBackupContentSession $sss = $ss | ?{$_.id -eq $ssid} $state = $sss.StateString } Write-Host \"虚拟机 $VMName 的还原点 $pttime 已挂载。\" -ForegroundColor Green $mountinfo = Get-VBRPublishedBackupContentInfo -Session $sss $mountinfomode = $mountinfo.mode $mountinfoserverip = $mountinfo.serverips $mountinfoserverport = $mountinfo.serverport $mountinfodiskname = $mountinfo.disks.diskname Write-Host \" 挂载点已经通过 $mountinfomode 挂载\" Write-Host \" 挂载磁盘信息： $mountinfodiskname \" Write-Host \" iSCSI客户端连接访问地址：$mountinfoserverip \" Write-Host \" iSCSI客户端连接访问端口：$mountinfoserverport \" Invoke-Command {exit} } ","wordCount":"521","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Lei Wei"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://newblog.backupnext.cloud/post/2020-07-13-data-integration-api/"},"publisher":{"@type":"Organization","name":"Backup next cloud","logo":{"@type":"ImageObject","url":"https://newblog.backupnext.cloud/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://newblog.backupnext.cloud/ accesskey=h title="Lei Wei's blog (Alt + H)">Lei Wei's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://newblog.backupnext.cloud/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://newblog.backupnext.cloud/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://newblog.backupnext.cloud/search/ title=Search><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>数据集成API真的就只是API？</h1><div class=post-meta>Lei Wei&nbsp;|&nbsp;<a href=https://github.com/Coku2015/Coku2015.github.io/blob/master/content/post/2020-07-13-Data%20integration%20API.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%8a%9f%e8%83%bd aria-label=功能>功能</a></li><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95 aria-label=使用方法>使用方法</a></li></ul></div></details></div><div class=post-content><p>Veeam发布v10之后，推出了一个全新的功能，但是这个功能深深的埋藏在了Powershell API之下，并且被冠了一个令人高不可攀的名称：数据集成API。我相信很多朋友看完这个名字，就可能不太想了解这个功能。对于系统管理员来说，有点略复杂了，还要开发什么东西才能把这个用起来？算了还是不用了。</p><h2 id=功能>功能<a hidden class=anchor aria-hidden=true href=#功能>#</a></h2><p>其实这个功能并不是那么的复杂，我们先来了解下怎么回事。</p><p>这个功能其实是通过iSCSI的磁盘服务，将备份存档通过iSCSI发布给相关服务器使用。它是数据利用的新形态，也就是说任何的Veeam的镜像级备份存档，都可以通过这种形式挂载给服务器去访问里面的数据。它和即时虚拟机恢复有那么一点点像，但是完全不一样的是，它完全不依赖于虚拟化环境，不依赖VMware和Hyper-V，而是将数据直接通过iSCSI服务发布给Windows或者Linux系统访问。在VBR中，绝大多数镜像级的备份存档都支持这种形式的发布：</p><ul><li>VMware镜像级备份</li><li>VMware镜像级复制</li><li>Hyper-V镜像级备份</li><li>Hyper-V镜像级复制</li><li>Veeam Agent for Windows的镜像级备份</li><li>Veeam Agent for Linux的镜像级备份</li></ul><h2 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h2><p>iSCSI挂载的工作原理非常简单，在API发起后，VBR的挂载服务器相当于变成一台iSCSI的存储机头，它能为所有可以访问iSCSI存储的系统提供iSCSI的服务，而这里面提供出去的数据则是VBR的存档，管理员可以按需从备份或复制存档中选择需要的数据。在这个数据集成服务建立起来后，数据使用者可以通过iSCSI的存储协议，直接挂载发布出来的卷，读取其中的数据，使用其中的数据。如图所示，在数据集成服务将备份存档发布后，备份系统变成了一套iSCSI的存储系统，里面存放的数据是之前的历史备份数据。</p><p><img loading=lazy src=https://s1.ax1x.com/2020/07/11/U1SPje.png alt=U1SPje.png></p><h2 id=使用方法>使用方法<a hidden class=anchor aria-hidden=true href=#使用方法>#</a></h2><p>因为它以API形式开放给用户使用，因此在VBR控制台上并没有直接的按钮来使用，但是这完全挡不住我们使用这么优秀的功能。可以直接使用本文最后面的这个Powershell的脚本来实现这个功能，需要做的很简单，只要copy脚本内容到记事本，存成.ps1文件，然后在VBR服务器的Powershell控制台中执行这个交互式脚本即可，按照脚本执行过程中的提示输入必要的信息就能成功将存档通过iSCSI发布出来了。</p><p>执行脚本后，会看到Powershell控制台上输入内容后会看到以下效果：</p><p><img loading=lazy src=https://s1.ax1x.com/2020/07/13/UJfszR.png alt=UJfszR.png></p><p>而此时，在VBR上会看到发布出来的磁盘信息，它以Instant Recovery显示在VBR控制台中。</p><p><img loading=lazy src=https://s1.ax1x.com/2020/07/13/UJfTSA.png alt=UJfTSA.png></p><p>接下来，我们可以来到iSCSI客户端上，比如刚刚在脚本执行时输入IP地址的机器10.10.1.175上，打开Windows的iSCSI Initiator，填入iSCSI的target为10.10.1.201，端口默认3260，来挂载这个iSCSI卷了。</p><p>在使用结束后，不要忘了在VBR上点击Stop Publishing来回收这个iSCSI卷。</p><p>以上就是简单实用的新功能，iSCSI发布。赶紧下载VBR装上试一下吧。</p><p>附上脚本：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#75715e># 本脚本是Veeam DataIntegration API的使用样例</span>
<span style=color:#75715e># 用于通过iSCSI方式将备份数据挂载给指定的系统进行使用</span>
<span style=color:#75715e># 使用脚本需要至少有7个还原点以上，否则请修改脚本使用</span>
<span style=color:#75715e># 脚本暂时仅限VMware、Hyper-V的主备份存档，如需Agent、Backup Copy、Replication、Storage Snapshot，请根据需求修改脚本。</span>
<span style=color:#75715e>#</span>
<span style=color:#75715e># 脚本作者：Wei Lei</span>
<span style=color:#75715e># Email:lei.wei@veeam.com</span>
<span style=color:#75715e># 脚本版本：v1.1</span>
<span style=color:#75715e>################# Update log ######################</span>
<span style=color:#75715e># 更新了VBR用户名密码错误后立刻停止脚本；</span>
<span style=color:#75715e># 更新了还原点选择错误后，自动终止脚本；</span>
<span style=color:#75715e>###################################################</span>

<span style=color:#75715e># Script Start</span>
<span style=color:#75715e># VBR Server (Server Name, FQDN or IP)</span>
$vbrServer = Read-Host <span style=color:#e6db74>&#34;请输入VBR地址，可以是域名或者IP&#34;</span>
<span style=color:#75715e># VBR Credentials</span>
Write-Host <span style=color:#e6db74>&#34;请在弹出对话框中输入VBR的用户名密码。&#34;</span>
$Credential=Get-Credential -Message 请输入VBR的用户名密码
$vbrusername = $Credential.Username
$vbrpassword = $Credential.GetNetworkCredential().password

<span style=color:#75715e>#region Connect</span>
<span style=color:#75715e># Load Veeam Snapin</span>
<span style=color:#66d9ef>If</span> (!(Get-PSSnapin -Name VeeamPSSnapIn -ErrorAction SilentlyContinue))
{
    <span style=color:#66d9ef>If</span> (!(Add-PSSnapin -PassThru VeeamPSSnapIn))
    {
        Write-Error <span style=color:#e6db74>&#34;Unable to load Veeam snapin&#34;</span> -ForegroundColor Red
        Exit
  }
}

<span style=color:#75715e># Connect to VBR server</span>
$OpenConnection = (Get-VBRServerSession).Server
<span style=color:#66d9ef>If</span> ($OpenConnection <span style=color:#f92672>-ne</span> $vbrServer)
{
    Disconnect-VBRServer
    <span style=color:#66d9ef>Try</span>
    {
        Connect-VBRServer -user $vbrusername -password $vbrpassword -server $vbrServer -ErrorAction Stop
    }
    <span style=color:#66d9ef>Catch</span>
    {
        Write-Host <span style=color:#e6db74>&#34;无法连接到VBR服务器 - $vbrServer&#34;</span> -ForegroundColor Red
        exit
    }
}
<span style=color:#75715e>#endregion</span>

$VMName = Read-Host <span style=color:#e6db74>&#34;请输入需要用于挂载的虚拟机名称&#34;</span>
$IP =Read-Host <span style=color:#e6db74>&#34;要挂载到哪台服务器（IP地址）？&#34;</span>
$backup = Get-VBRBackup
$backup = @($backup | ?{$_.JobType <span style=color:#f92672>-eq</span> <span style=color:#e6db74>&#34;Backup&#34;</span>})
$points = Get-VBRRestorePoint -Backup $backup -Name $VMName | Sort-Object <span style=color:#960050;background-color:#1e0010>–</span>Property CreationTime <span style=color:#960050;background-color:#1e0010>–</span>Descending | Select-Object -First 7
<span style=color:#66d9ef>if</span> ($points <span style=color:#f92672>-eq</span> $null)
{
    Write-Host <span style=color:#e6db74>&#34;找不到这台虚拟机的还原点。 - $VMName&#34;</span> -ForegroundColor Red
    exit
}

<span style=color:#66d9ef>While</span>($InNumber <span style=color:#f92672>-ne</span> 7)
    {
    Write-Host <span style=color:#e6db74>&#34;##############已找到虚拟机 $VMName 的最近7个还原点##############&#34;</span> -ForegroundColor Green
    $i = 0
    <span style=color:#66d9ef>foreach</span> ($pt <span style=color:#66d9ef>in</span> $points) 
    {
    $ptctime = $pt.CreationTime
    $i = $i + 1
    Write-Host <span style=color:#e6db74>&#34;#&#34;</span> $i . $ptctime <span style=color:#e6db74>&#34;;&#34;</span>
    }
    Write-Host <span style=color:#e6db74>&#34;#############################################################&#34;</span> -ForegroundColor Green
    
    $InNumber = Read-Host <span style=color:#e6db74>&#34;请选择还原点（1-7）&#34;</span>
    $ss =@()

    <span style=color:#66d9ef>switch</span>($InNumber)
    {
        1
        {
            $pt = $points | Select-Object -Index 0
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        2
        {
            $pt = $points | Select-Object -Index 1
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        3
        {
            $pt = $points | Select-Object -Index 2
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        4
        {
            $pt = $points | Select-Object -Index 3
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        5
        {
            $pt = $points | Select-Object -Index 4
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        6
        {
            $pt = $points | Select-Object -Index 5
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        7
        {
            $pt = $points | Select-Object -Index 6
            $pttime = $pt.CreationTime
            Write-Host <span style=color:#e6db74>&#34;已选择还原点 $pttime 。&#34;</span> -ForegroundColor Green
            $ss = Publish-VBRBackupContent -RestorePoint $pt -AllowedIps $IP -RunAsync
        }
        <span style=color:#66d9ef>Default</span> 
        { 
        Write-Error <span style=color:#e6db74>&#34;请输入1-7之间的数字!&#34;</span>
        Invoke-Command {exit}
        }
    }
    Write-Host <span style=color:#e6db74>&#34;正在挂载还原点...&#34;</span>
    $state = $ss.StateString
    $ssid = $ss.id
    <span style=color:#66d9ef>While</span> ($state <span style=color:#f92672>-ne</span> <span style=color:#e6db74>&#34;Virtual disks published...&#34;</span>)
    {
        Start-Sleep -s 5
        $ss = Get-VBRPublishedBackupContentSession
        $sss = $ss | ?{$_.id <span style=color:#f92672>-eq</span> $ssid}
        $state = $sss.StateString
    }
    Write-Host <span style=color:#e6db74>&#34;虚拟机 $VMName 的还原点 $pttime 已挂载。&#34;</span> -ForegroundColor Green
    $mountinfo = Get-VBRPublishedBackupContentInfo -Session $sss
    $mountinfomode = $mountinfo.mode
    $mountinfoserverip = $mountinfo.serverips
    $mountinfoserverport = $mountinfo.serverport
    $mountinfodiskname = $mountinfo.disks.diskname
    Write-Host <span style=color:#e6db74>&#34;    挂载点已经通过 $mountinfomode 挂载&#34;</span>
    Write-Host <span style=color:#e6db74>&#34;    挂载磁盘信息： $mountinfodiskname &#34;</span>
    Write-Host <span style=color:#e6db74>&#34;    iSCSI客户端连接访问地址：$mountinfoserverip &#34;</span>
    Write-Host <span style=color:#e6db74>&#34;    iSCSI客户端连接访问端口：$mountinfoserverport &#34;</span>
    Invoke-Command {exit}
}

</code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://newblog.backupnext.cloud/tags/automation/>Automation</a></li><li><a href=https://newblog.backupnext.cloud/tags/powershell/>Powershell</a></li></ul><nav class=paginav><a class=prev href=https://newblog.backupnext.cloud/post/2017-05-05-how-to-calculate-backup-size/><span class=title>« Prev Page</span><br><span>数据中心备份容量和带宽的计算方法</span></a>
<a class=next href=https://newblog.backupnext.cloud/post/2017-04-20-secret-in-file-level-recovery/><span class=title>Next Page »</span><br><span>文件级恢复的秘密</span></a></nav></footer></article></main><footer class=footer><span>Copyright Lei Wei</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>